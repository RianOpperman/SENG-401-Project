"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Socket_instances, _Socket_ws, _Socket_url, _Socket_closed, _Socket_status, _Socket_init;
Object.defineProperty(exports, "__esModule", { value: true });
const node_js_1 = __importDefault(require("../ws/node.js"));
const emitter_js_1 = __importDefault(require("./emitter.js"));
const OPENED = Symbol("Opened");
const CLOSED = Symbol("Closed");
class Socket extends emitter_js_1.default {
    constructor(url) {
        super();
        _Socket_instances.add(this);
        _Socket_ws.set(this, void 0);
        _Socket_url.set(this, void 0);
        _Socket_closed.set(this, false);
        _Socket_status.set(this, CLOSED);
        Object.defineProperty(this, "ready", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolve", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        __classPrivateFieldGet(this, _Socket_instances, "m", _Socket_init).call(this);
        __classPrivateFieldSet(this, _Socket_url, String(url)
            .replace("http://", "ws://")
            .replace("https://", "wss://"), "f");
    }
    open() {
        __classPrivateFieldSet(this, _Socket_ws, new node_js_1.default(__classPrivateFieldGet(this, _Socket_url, "f")), "f");
        // Setup event listeners so that the
        // Surreal instance can listen to the
        // necessary event types.
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("message", (e) => {
            this.emit("message", e);
        });
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("error", (e) => {
            this.emit("error", e);
        });
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("close", (e) => {
            this.emit("close", e);
        });
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("open", (e) => {
            this.emit("open", e);
        });
        // If the WebSocket connection with the
        // database was disconnected, then we need
        // to reset the ready promise.
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("close", () => {
            if (__classPrivateFieldGet(this, _Socket_status, "f") === OPENED) {
                __classPrivateFieldGet(this, _Socket_instances, "m", _Socket_init).call(this);
            }
        });
        // When the WebSocket is opened or closed
        // then we need to store the connection
        // status within the status property.
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("close", () => {
            __classPrivateFieldSet(this, _Socket_status, CLOSED, "f");
        });
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("open", () => {
            __classPrivateFieldSet(this, _Socket_status, OPENED, "f");
        });
        // If the connection is closed, then we
        // need to attempt to reconnect on a
        // regular basis until we are successful.
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("close", () => {
            if (__classPrivateFieldGet(this, _Socket_closed, "f") === false) {
                setTimeout(() => {
                    this.open();
                }, 2500);
            }
        });
        // When the WebSocket successfully opens
        // then let's resolve the ready promise so
        // that promise based code can continue.
        __classPrivateFieldGet(this, _Socket_ws, "f").addEventListener("open", () => {
            this.resolve();
        });
    }
    send(data) {
        __classPrivateFieldGet(this, _Socket_ws, "f").send(data);
    }
    close(code = 1000, reason = "Some reason") {
        __classPrivateFieldSet(this, _Socket_closed, true, "f");
        __classPrivateFieldGet(this, _Socket_ws, "f").close(code, reason);
    }
}
exports.default = Socket;
_Socket_ws = new WeakMap(), _Socket_url = new WeakMap(), _Socket_closed = new WeakMap(), _Socket_status = new WeakMap(), _Socket_instances = new WeakSet(), _Socket_init = function _Socket_init() {
    this.ready = new Promise((resolve) => {
        this.resolve = resolve;
    });
};
//# sourceMappingURL=socket.js.map